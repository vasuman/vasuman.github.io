<!DOCTYPE html>
<html lang="en">
<head>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>
         aleph_null 
    </title>
    

    <link rel="stylesheet" href="/static/css/blog.css">
    
<link rel="stylesheet" href="/static/css/pygments.css">

    
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-40829655-2', 'auto');
        ga('send', 'pageview');
    </script>
    

</head>
<body>
    <div id="header" > 
        <a href="/"><h1> aleph_null </h1></a> 
        <h2> Nothing to see here </h2>
    </div>
    <nav>
        <ul>
            
            <li>
                <a href="/index.html">Posts</a>
            </li>
            
            <li>
                <a href="/about.html">About</a>
            </li>
            
        </ul>
    </nav>
    <div id="content">
    
    <article>
        <div class="post-description">
            <h3>Augmented Chaining</h3>
            <time datetime="2013-05-19">19 May 2013</time>
        </div>
        <p>In search of a decent inheritance model for game development in
JavaScript, I looked at many design patterns. The aim being to build a
robust system to manage in-game entities to find the ideal trade-off
between <em>game performance</em> and <em>code cleanliness</em>. Not that good code
can't be both at the same time.</p>
<h2>A new approach</h2>
<p>Well, traditional JavaScript inheritance is focused on being linear,
though you can implement multiple inheritance by individually copying
members between objects, it seems a little too <em>hackish</em>.</p>
<p>I decided to follow the <em>protoypal</em>; inheritance model. Objects
inherit from other objects and so on.</p>
<p>In <strong>Augmented Chaining</strong>, we focus on three major principles,</p>
<ol>
<li>
<p>Property Augmentation</p>
</li>
<li>
<p>Function chains</p>
</li>
<li>
<p>Object constructors</p>
</li>
</ol>
<h3>Property Augmentation</h3>
<p>Given an object that defines a basic 2-dimensional rectangular
shape. By adding an object containing sprite data such as <em>image name</em>
and <em>image source size</em>, etc. to the current object we can <strong>augment</strong>
the properties of the current object.</p>
<p>Take note here that the underlying 2-D properties are unaffected by
the augmentation; <em>i.e.</em> It still posses an 'x' and 'y' co-ordinate to
draw on the canvas.</p>
<p>Here we use two <strong>awesome</strong> methods supplied by all JavaScript
functions,</p>
<ol>
<li>
<p><code>apply</code></p>
</li>
<li>
<p><code>call</code></p>
</li>
</ol>
<p>Now, suppose we have a constructor that already defines the object we
can <strong>augment</strong> the <em>old</em> constructor; by defining a <em>new</em> constructor
and calling the same old constructor on the object by using the <code>call</code>
method that each <code>[Function]</code> is provided with in JavaScript.</p>
<p>What <code>call</code> does is simply change all references of the <code>this</code> object
in the function code to the object supplied by the
programmer. <strong>i.e.</strong> Change the current context of the function to
inside the object</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span class="kd">var</span> <span class="nx">myObj</span><span class="o">=</span><span class="p">{</span> <span class="nx">x</span><span class="o">:</span> <span class="mi">4</span> <span class="p">};</span>

<span class="kd">function</span> <span class="nx">changeProps</span><span class="p">(){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">y</span><span class="o">=</span><span class="mi">6</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">z</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Traditionally, creating a new object is like,</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span class="kd">var</span> <span class="nx">newObj</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">changeProps</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newObj</span><span class="p">);</span>
<span class="c1">// {y:6, z:2}</span>
</pre></div>
</td></tr></table>

<p>But, to <em>augment</em> the older object</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span class="nx">changeProps</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">myObj</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">myObj</span><span class="p">);</span>
<span class="c1">// {x: 4, y: 6, z: 2}</span>
</pre></div>
</td></tr></table>

<p>The <code>apply</code> function also operates similarly, the only difference
being the way in which parameters are passed.
<em> In <code>call</code> the arguments following the <em>object name</em> are passed
  as parameters</em> In <code>apply</code> an <code>Array</code> of arguments is supplied after the <em>object
  name</em></p>
<p>While defining a new constructor, we can use this principle to make
sure that the created object also contains all the <em>base</em> properties
as well as the <em>augmented</em> properties.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="codehilite"><pre><span class="kd">function</span> <span class="nx">basicObject</span><span class="p">(</span><span class="nx">objDesc</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">objDesc</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">objDesc</span><span class="p">.</span><span class="nx">y</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">doStuff</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;Still alive&quot;</span><span class="p">);</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">augmentedObject</span><span class="p">(</span><span class="nx">objDesc</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">basicObject</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">objDesc</span><span class="p">)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">newProp</span> <span class="o">=</span> <span class="nx">objDesc</span><span class="p">.</span><span class="nx">z</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">augFunc</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Even better&#39;</span><span class="p">);</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">tmp</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">augmentedObject</span><span class="p">({</span><span class="nx">x</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span><span class="mi">2</span><span class="p">,</span> <span class="nx">z</span><span class="o">:</span><span class="mi">3</span><span class="p">});</span>
<span class="c1">// tmp = { x:1, y:2, doStuff:[Function], newProp:3, augFunc:[Function] }</span>
</pre></div>
</td></tr></table>

<h3>Function chains</h3>
<p>Now, an interesting thing happens. Suppose, we change a <code>prototype</code>
method of the basic object</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span class="nx">basicObject</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">exclusiveMethod</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span>  <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;I&#39;m superior&quot;</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</td></tr></table>

<p>This method is not accessable via the augmented object</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span class="c1">//tmp is a new instance of augmentedObject</span>
<span class="kd">var</span> <span class="nx">tmp</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">augmentedObject</span><span class="p">({</span><span class="nx">x</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span><span class="mi">2</span><span class="p">,</span> <span class="nx">z</span><span class="o">:</span><span class="mi">3</span><span class="p">});</span>
<span class="nx">tmp</span><span class="p">.</span><span class="nx">exclusiveMethod</span><span class="p">()</span>   <span class="c1">//ERROR!!! is thrown</span>

<span class="kd">var</span> <span class="nx">tmp1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">basicObject</span><span class="p">({</span><span class="nx">x</span><span class="o">:</span><span class="mi">5</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span><span class="mi">8</span><span class="p">});</span>
<span class="nx">tmp1</span><span class="p">.</span><span class="nx">exclusiveMethod</span><span class="p">()</span>  <span class="c1">//Will work</span>
</pre></div>
</td></tr></table>

<p>This is because we only initialized the object by applying the basic
<code>constructor</code> alone to the augmented object. We also have to assign
the prototype of the basic object to the <em>augmented</em> object.</p>
<p>The <code>__proto__</code> property holds the prototype of the <em>created</em>
object. We now assign the <code>__proto__</code> property of the <code>prototype</code> of
the <em>augmented</em> constructor to the <code>prototype</code> of the <em>base</em>
constructor. This <strong>links</strong> the prototype chains</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="nx">augmentedObject</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nx">basicObject</span><span class="p">.</span><span class="nx">prototype</span>
</pre></div>
</td></tr></table>

<p>Otherwise, simply construct an ideal object. It really doesn't matter
since we only care about the <code>prototype</code> of the object which isn't
dictated by the constructor</p>
<p>Now, a very common practice in <strong>Game Development</strong> is to update game
entities every iteration. Consider the scenario where we've created an
<em>augmented</em> object. When we call it's <code>update</code> method, the
<code>basicObject</code>'s <code>update</code> method is <em>obfuscated</em>. This may cause shit
to break!!</p>
<p>When we augment the properties of an object, we expect the base
properties to still function. The solution to this is to use <strong>Method
Chains</strong>.</p>
<p>Since, we have linked up the prototypes of the <em>augmented</em> and <em>base</em>
objects, we're in luck here.</p>
<p>An <strong>important note</strong> here, the functions must be defined as part of
the constructor's <code>prototype</code> member, as is considered good practice.</p>
<p>This is how we define a <code>chain</code> method. This method takes a method name
and looks up all prototypes of the given object till the method is not
present and applies each one on the current object - <code>this</code>;</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span class="nx">basicObject</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">chain</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">methodname</span><span class="p">,</span> <span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="k">this</span><span class="p">.</span><span class="nx">__proto</span><span class="p">;</span> <span class="nx">i</span><span class="p">[</span><span class="nx">methodname</span><span class="p">];</span> <span class="nx">i</span><span class="o">=</span><span class="nx">i</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">i</span><span class="p">[</span><span class="nx">methodname</span><span class="p">].</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
    <span class="p">};</span>
<span class="p">};</span>
</pre></div>
</td></tr></table>

<p>We loop through all prototypes of the main object and then, execute
each update method in the context of the current object. Which should
execute successfully since it has also been initialized with the
properties of that <code>prototype</code> s constructor.</p>
<p>Suppose we define an update method on both the <em>basic</em> and <em>augmented</em>
objects.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span class="nx">basicObject</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">update</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">augmentedObject</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">update</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">z</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p><strong>Reset</strong> the prototype of <em>augmented</em> object.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span class="nx">augmentedObject</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nx">basicObject</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
</pre></div>
</td></tr></table>

<p>Now,</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span class="kd">var</span> <span class="nx">tmp2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">augmenetedObject</span><span class="p">({</span><span class="nx">x</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span><span class="mi">2</span><span class="p">,</span> <span class="nx">z</span><span class="o">:</span><span class="mi">3</span><span class="p">});</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">tmp2</span><span class="p">.</span><span class="nx">x</span><span class="o">+</span><span class="s2">&quot;, &quot;</span><span class="o">+</span><span class="nx">tmp2</span><span class="p">.</span><span class="nx">y</span><span class="o">+</span><span class="s2">&quot;, &quot;</span><span class="o">+</span><span class="nx">tmp</span><span class="p">.</span><span class="nx">z</span><span class="p">);</span>         <span class="c1">// 1, 2, 3</span>
<span class="nx">tmp2</span><span class="p">.</span><span class="nx">chain</span><span class="p">(</span><span class="s1">&#39;update&#39;</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">tmp2</span><span class="p">.</span><span class="nx">x</span><span class="o">+</span><span class="s2">&quot;, &quot;</span><span class="o">+</span><span class="nx">tmp2</span><span class="p">.</span><span class="nx">y</span><span class="o">+</span><span class="s2">&quot;, &quot;</span><span class="o">+</span><span class="nx">tmp</span><span class="p">.</span><span class="nx">z</span><span class="p">);</span>         <span class="c1">// 2, 2, 4</span>
</pre></div>
</td></tr></table>

<p>As you can see, the <code>update</code> functions of both the <code>baseObject</code> and
the <code>augmentedObject</code> are called. The <code>x</code> and <code>z</code> values are updated.</p>
<p>For those of you who are wondering why somebody would want to do
this. Well, consider the scenario where you have a <strong>Player</strong> object
that is an <em>augmented</em> <strong>Physics</strong> object. The <code>update</code> function of
the physics object usually updates the <code>x</code> and <code>y</code> coordinates of the
object. Now the player object s <code>update</code> moves the player around. A
typical <code>update</code> call on this object will cause the player <code>update</code> to
execute but <strong>not</strong> the physics <code>update</code>. Of course, you could always
copy the code from the physics <code>update</code>, but that s a <em>dirty</em>
solution.</p>
<h3>Object Constructors</h3>
<p>This point is not so much of a principle as a guideline of good
practice. Now, as we have seen we chain constructors together.</p>
<p>If we still try to access <em>formal parameters</em> by ordering in function
definition, things are bound to get pretty screwed up.</p>
<p>As a rule, it s better that all object constructors only accept a
single object as a formal parameter and all parameters are accessed by
name, as keys of that object.</p>
<p>Those familiar with the python <code>**kwargs</code> will realize the
resemblance. The <code>**kwargs</code> formal parameter denotes a dictionary that
matches all <em>named actual parameters</em> supplied to the function.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span class="k">def</span> <span class="nf">echo_args</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">print</span> <span class="n">kwargs</span>

<span class="n">echo_args</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="c"># {&#39;a&#39;:1, &#39;b&#39;:2, &#39;c&#39;:3, &#39;d&#39;:4}</span>
</pre></div>
</td></tr></table>

<p>In this practice, we take an object as an argument to the constructor
for another object. This helps greatly in making the game more
<em>data-driven</em>.</p>
<p>Theoretically once, we have a required list of object constructors, we
can design something similar to a <strong>Universal Turing Machine</strong> called
a <strong>Universal Game Engine</strong> that simply parses a JSON file and
re-creates the entire game state based on the information stored in
that single JSON string. Since, the arguments to every constructor can
be stored as JSON, the name of the constructor can also be stored. All
the game engine would have to do would be to simply initialize all the
objects</p>
<h2>Other paradigms</h2>
<p>This was heavily influenced by the following styles</p>
<h3>Class-based</h3>
<p>It's arguably the most commonly used programming paradigm. Most <em>Intro
to Programming</em> lessons begin with an Object-Oriented approach using
Classes.</p>
<p>There
<a href="http://ejohn.org/blog/simple-javascript-inheritance/">this</a>
small library by John Reiseg that emulates class based inheritance in
JavaScript.</p>
<p>Well, the reason I didn't choose this approach was because it's simply
<em>too familiar</em>.</p>
<h3>Entity-component</h3>
<p>This was a really interesting paradigm that I came across while
playing with this game engine called
<a href="/web/20130818231944/http://craftyjs.com/">Crafty.js</a>. In this
approach,</p>
<ol>
<li>
<p>Objects are called <strong>entities</strong></p>
</li>
<li>
<p><strong>Components</strong> are pluggable interfaces that provide a piece of
    functionality to an entity</p>
</li>
</ol>
<p>There's <em>no</em> inheritance structure, <em>no</em> constructors.</p>
<p>Functions and member variables are described in the component
definition. These components are added to various entities that are
the objects in the game. When a component is added to an object in the
game, all the functions and variables defined in the component are
copied onto the object.</p>
<p><strong>For example,</strong></p>
<ul>
<li>
<p>A component describing functions for <em>character movement</em> will be
  plugged into the object describing the <em>main player character</em>.</p>
</li>
<li>
<p>A component simulating the effects of <em>gravity</em> -containing variable
  storing the acceleration constant <strong>and</strong> a function that updates
  each frame and decreases the object's <em>Y-coordinate</em> by some amount;
  will be plugged into all objects except those part of the fixed
  environment.</p>
</li>
<li>
<p>An entity describing a map tile will have a <em>collision detection</em>
  component plugged in</p>
</li>
</ul>
<p>I guess you get the point by now.</p>
<p>Most entity interaction is handled by firing and trapping different
named events.</p>
<p>As you can see, the focus of programming has shifted from deciding how
each different object should be defined. We now simply find the
distinct properties each object posses; code it and then, plug them
into various objects in the game.</p>
<p>This approach is radically different in its non-adherence to any form
of inheritance. It provides <strong>tons</strong> of flexibility in defining game
objects.</p>
<p>This model exemplifies a <em>data-driven</em> approach. Given a comprehensive
set of components, the game programmers job is reduced to simply
deciding the list of components to plug into each object in the game.</p>
<p>Be sure to check out,</p>
<h2>Gist</h2>
<script src="https://gist.github.com/vasuman/5606716.js"></script>
    </article>

    </div>
    <footer>
        <address>
            <a id="email-link" href="http://www.google.com/recaptcha/mailhide/d?k=01njzLR0aH4z04V6Ub8eE02A==&c=wQG6gFC9MCTJ0_ZX9EXgPQ76e1BDEj8fxMzMmhnMhL8=">Vasuman Ravichandran</a>
        </address>
        <div id="accounts">
            <ul>
                 
                <li><a href="https://github.com/vasuman">GitHub</a></li>
                
                
            </ul>
        </div>
        <div id="creds">
            Generated using, <a href="https://github.com/vasuman/glob">glob</a>
        </div>
    </footer>
</body>
</html>